--- a/net/wireless/chan.c	2025-03-22 10:59:23.202096272 +0000
+++ b/net/wireless/chan.c	2025-03-22 10:59:23.202096272 +0000
@@ -55,56 +55,6 @@
 }
 EXPORT_SYMBOL(cfg80211_chandef_create);
 
-static int cfg80211_chandef_get_width(const struct cfg80211_chan_def *c)
-{
-	return nl80211_chan_width_to_mhz(c->width);
-}
-
-static u32 cfg80211_get_start_freq(const struct cfg80211_chan_def *chandef,
-				   u32 cf)
-{
-	u32 start_freq, center_freq, bandwidth;
-
-	center_freq = MHZ_TO_KHZ((cf == 1) ?
-			chandef->center_freq1 : chandef->center_freq2);
-	bandwidth = MHZ_TO_KHZ(cfg80211_chandef_get_width(chandef));
-
-	if (bandwidth <= MHZ_TO_KHZ(20))
-		start_freq = center_freq;
-	else
-		start_freq = center_freq - bandwidth / 2 + MHZ_TO_KHZ(10);
-
-	return start_freq;
-}
-
-static u32 cfg80211_get_end_freq(const struct cfg80211_chan_def *chandef,
-				 u32 cf)
-{
-	u32 end_freq, center_freq, bandwidth;
-
-	center_freq = MHZ_TO_KHZ((cf == 1) ?
-			chandef->center_freq1 : chandef->center_freq2);
-	bandwidth = MHZ_TO_KHZ(cfg80211_chandef_get_width(chandef));
-
-	if (bandwidth <= MHZ_TO_KHZ(20))
-		end_freq = center_freq;
-	else
-		end_freq = center_freq + bandwidth / 2 - MHZ_TO_KHZ(10);
-
-	return end_freq;
-}
-
-#define for_each_subchan(chandef, freq, cf)				\
-	for (u32 punctured = chandef->punctured,			\
-	     cf = 1, freq = cfg80211_get_start_freq(chandef, cf);	\
-	     freq <= cfg80211_get_end_freq(chandef, cf);		\
-	     freq += MHZ_TO_KHZ(20),					\
-	     ((cf == 1 && chandef->center_freq2 != 0 &&			\
-	       freq > cfg80211_get_end_freq(chandef, cf)) ?		\
-	      (cf++, freq = cfg80211_get_start_freq(chandef, cf),	\
-	       punctured = 0) : (punctured >>= 1)))			\
-		if (!(punctured & 1))
-
 struct cfg80211_per_bw_puncturing_values {
 	u8 len;
 	const u16 *valid_values;
@@ -308,6 +258,11 @@
 }
 EXPORT_SYMBOL(nl80211_chan_width_to_mhz);
 
+static int cfg80211_chandef_get_width(const struct cfg80211_chan_def *c)
+{
+	return nl80211_chan_width_to_mhz(c->width);
+}
+
 static bool cfg80211_valid_center_freq(u32 center,
 				       enum nl80211_chan_width width)
 {
@@ -334,7 +289,7 @@
 
 	/*
 	 * Valid channels are packed from lowest frequency towards higher ones.
-	 * So test that the lower frequency aligns with one of these steps.
+	 * So test that the lower frequency alignes with one of these steps.
 	 */
 	return (center - bw / 2 - 5945) % step == 0;
 }
@@ -627,11 +582,31 @@
 }
 EXPORT_SYMBOL(cfg80211_chandef_compatible);
 
+static void cfg80211_set_chans_dfs_state(struct wiphy *wiphy, u32 center_freq,
+					 u32 bandwidth,
+					 enum nl80211_dfs_state dfs_state)
+{
+	struct ieee80211_channel *c;
+	u32 freq;
+
+	for (freq = center_freq - bandwidth/2 + 10;
+	     freq <= center_freq + bandwidth/2 - 10;
+	     freq += 20) {
+		c = ieee80211_get_channel(wiphy, freq);
+		if (!c || !(c->flags & IEEE80211_CHAN_RADAR))
+			continue;
+
+		c->dfs_state = dfs_state;
+		c->dfs_state_entered = jiffies;
+		if (dfs_state == NL80211_DFS_AVAILABLE)
+			c->dfs_state_last_available = jiffies;
+	}
+}
+
 void cfg80211_set_dfs_state(struct wiphy *wiphy,
 			    const struct cfg80211_chan_def *chandef,
 			    enum nl80211_dfs_state dfs_state)
 {
-	struct ieee80211_channel *c;
 	int width;
 
 	if (WARN_ON(!cfg80211_chandef_valid(chandef)))
@@ -641,16 +616,41 @@
 	if (width < 0)
 		return;
 
-	for_each_subchan(chandef, freq, cf) {
-		c = ieee80211_get_channel_khz(wiphy, freq);
-		if (!c || !(c->flags & IEEE80211_CHAN_RADAR))
-			continue;
+	cfg80211_set_chans_dfs_state(wiphy, chandef->center_freq1,
+				     width, dfs_state);
 
-		c->dfs_state = dfs_state;
-		c->dfs_state_entered = jiffies;
-		if (dfs_state == NL80211_DFS_AVAILABLE)
-			c->dfs_state_last_available = jiffies;
-	}
+	if (!chandef->center_freq2)
+		return;
+	cfg80211_set_chans_dfs_state(wiphy, chandef->center_freq2,
+				     width, dfs_state);
+}
+
+static u32 cfg80211_get_start_freq(u32 center_freq,
+				   u32 bandwidth)
+{
+	u32 start_freq;
+
+	bandwidth = MHZ_TO_KHZ(bandwidth);
+	if (bandwidth <= MHZ_TO_KHZ(20))
+		start_freq = center_freq;
+	else
+		start_freq = center_freq - bandwidth / 2 + MHZ_TO_KHZ(10);
+
+	return start_freq;
+}
+
+static u32 cfg80211_get_end_freq(u32 center_freq,
+				 u32 bandwidth)
+{
+	u32 end_freq;
+
+	bandwidth = MHZ_TO_KHZ(bandwidth);
+	if (bandwidth <= MHZ_TO_KHZ(20))
+		end_freq = center_freq;
+	else
+		end_freq = center_freq + bandwidth / 2 - MHZ_TO_KHZ(10);
+
+	return end_freq;
 }
 
 static bool
@@ -727,12 +727,17 @@
 }
 
 static int cfg80211_get_chans_dfs_required(struct wiphy *wiphy,
-					   const struct cfg80211_chan_def *chandef,
+					    u32 center_freq,
+					    u32 bandwidth,
 					   enum nl80211_iftype iftype)
 {
 	struct ieee80211_channel *c;
+	u32 freq, start_freq, end_freq;
 
-	for_each_subchan(chandef, freq, cf) {
+	start_freq = cfg80211_get_start_freq(center_freq, bandwidth);
+	end_freq = cfg80211_get_end_freq(center_freq, bandwidth);
+
+	for (freq = start_freq; freq <= end_freq; freq += MHZ_TO_KHZ(20)) {
 		c = ieee80211_get_channel_khz(wiphy, freq);
 		if (!c)
 			return -EINVAL;
@@ -765,9 +770,25 @@
 		if (width < 0)
 			return -EINVAL;
 
-		ret = cfg80211_get_chans_dfs_required(wiphy, chandef, iftype);
+		ret = cfg80211_get_chans_dfs_required(wiphy,
+					ieee80211_chandef_to_khz(chandef),
+					width, iftype);
+		if (ret < 0)
+			return ret;
+		else if (ret > 0)
+			return BIT(chandef->width);
+
+		if (!chandef->center_freq2)
+			return 0;
+
+		ret = cfg80211_get_chans_dfs_required(wiphy,
+					MHZ_TO_KHZ(chandef->center_freq2),
+					width, iftype);
+		if (ret < 0)
+			return ret;
+		else if (ret > 0)
+			return BIT(chandef->width);
 
-		return (ret > 0) ? BIT(chandef->width) : ret;
 		break;
 	case NL80211_IFTYPE_STATION:
 	case NL80211_IFTYPE_OCB:
@@ -787,18 +808,16 @@
 }
 EXPORT_SYMBOL(cfg80211_chandef_dfs_required);
 
-bool cfg80211_chandef_dfs_usable(struct wiphy *wiphy,
-				 const struct cfg80211_chan_def *chandef)
+static int cfg80211_get_chans_dfs_usable(struct wiphy *wiphy,
+					 u32 center_freq,
+					 u32 bandwidth)
 {
 	struct ieee80211_channel *c;
-	int width, count = 0;
-
-	if (WARN_ON(!cfg80211_chandef_valid(chandef)))
-		return false;
+	u32 freq, start_freq, end_freq;
+	int count = 0;
 
-	width = cfg80211_chandef_get_width(chandef);
-	if (width < 0)
-		return false;
+	start_freq = cfg80211_get_start_freq(center_freq, bandwidth);
+	end_freq = cfg80211_get_end_freq(center_freq, bandwidth);
 
 	/*
 	 * Check entire range of channels for the bandwidth.
@@ -806,24 +825,61 @@
 	 * DFS_AVAILABLE). Return number of usable channels
 	 * (require CAC). Allow DFS and non-DFS channel mix.
 	 */
-	for_each_subchan(chandef, freq, cf) {
+	for (freq = start_freq; freq <= end_freq; freq += MHZ_TO_KHZ(20)) {
 		c = ieee80211_get_channel_khz(wiphy, freq);
 		if (!c)
-			return false;
+			return -EINVAL;
 
 		if (c->flags & IEEE80211_CHAN_DISABLED)
-			return false;
+			return -EINVAL;
 
 		if (c->flags & IEEE80211_CHAN_RADAR) {
 			if (c->dfs_state == NL80211_DFS_UNAVAILABLE)
-				return false;
+				return -EINVAL;
 
 			if (c->dfs_state == NL80211_DFS_USABLE)
 				count++;
 		}
 	}
 
-	return count > 0;
+	return count;
+}
+
+bool cfg80211_chandef_dfs_usable(struct wiphy *wiphy,
+				 const struct cfg80211_chan_def *chandef)
+{
+	int width;
+	int r1, r2 = 0;
+
+	if (WARN_ON(!cfg80211_chandef_valid(chandef)))
+		return false;
+
+	width = cfg80211_chandef_get_width(chandef);
+	if (width < 0)
+		return false;
+
+	r1 = cfg80211_get_chans_dfs_usable(wiphy,
+					   MHZ_TO_KHZ(chandef->center_freq1),
+					   width);
+
+	if (r1 < 0)
+		return false;
+
+	switch (chandef->width) {
+	case NL80211_CHAN_WIDTH_80P80:
+		WARN_ON(!chandef->center_freq2);
+		r2 = cfg80211_get_chans_dfs_usable(wiphy,
+					MHZ_TO_KHZ(chandef->center_freq2),
+					width);
+		if (r2 < 0)
+			return false;
+		break;
+	default:
+		WARN_ON(chandef->center_freq2);
+		break;
+	}
+
+	return (r1 + r2 > 0);
 }
 EXPORT_SYMBOL(cfg80211_chandef_dfs_usable);
 
@@ -985,10 +1041,10 @@
 		if (!reg_dfs_domain_same(wiphy, &rdev->wiphy))
 			continue;
 
-		guard(wiphy)(&rdev->wiphy);
-
+		wiphy_lock(&rdev->wiphy);
 		found = cfg80211_is_wiphy_oper_chan(&rdev->wiphy, chan) ||
 			cfg80211_offchan_chain_is_active(rdev, chan);
+		wiphy_unlock(&rdev->wiphy);
 
 		if (found)
 			return true;
@@ -997,6 +1053,42 @@
 	return false;
 }
 
+static bool cfg80211_get_chans_dfs_available(struct wiphy *wiphy,
+					     u32 center_freq,
+					     u32 bandwidth)
+{
+	struct ieee80211_channel *c;
+	u32 freq, start_freq, end_freq;
+	bool dfs_offload;
+
+	dfs_offload = wiphy_ext_feature_isset(wiphy,
+					      NL80211_EXT_FEATURE_DFS_OFFLOAD);
+
+	start_freq = cfg80211_get_start_freq(center_freq, bandwidth);
+	end_freq = cfg80211_get_end_freq(center_freq, bandwidth);
+
+	/*
+	 * Check entire range of channels for the bandwidth.
+	 * If any channel in between is disabled or has not
+	 * had gone through CAC return false
+	 */
+	for (freq = start_freq; freq <= end_freq; freq += MHZ_TO_KHZ(20)) {
+		c = ieee80211_get_channel_khz(wiphy, freq);
+		if (!c)
+			return false;
+
+		if (c->flags & IEEE80211_CHAN_DISABLED)
+			return false;
+
+		if ((c->flags & IEEE80211_CHAN_RADAR) &&
+		    (c->dfs_state != NL80211_DFS_AVAILABLE) &&
+		    !(c->dfs_state == NL80211_DFS_USABLE && dfs_offload))
+			return false;
+	}
+
+	return true;
+}
+
 static void
 __cfg80211_update_last_available(struct wiphy *wiphy,
 					 u32 center_freq,
@@ -1043,9 +1135,8 @@
 static bool cfg80211_chandef_dfs_available(struct wiphy *wiphy,
 				const struct cfg80211_chan_def *chandef)
 {
-	struct ieee80211_channel *c;
 	int width;
-	bool dfs_offload;
+	int r;
 
 	if (WARN_ON(!cfg80211_chandef_valid(chandef)))
 		return false;
@@ -1054,36 +1145,62 @@
 	if (width < 0)
 		return false;
 
-	dfs_offload = wiphy_ext_feature_isset(wiphy,
-					      NL80211_EXT_FEATURE_DFS_OFFLOAD);
+	r = cfg80211_get_chans_dfs_available(wiphy,
+					     MHZ_TO_KHZ(chandef->center_freq1),
+					     width);
 
-	/*
-	 * Check entire range of channels for the bandwidth.
-	 * If any channel in between is disabled or has not
-	 * had gone through CAC return false
-	 */
-	for_each_subchan(chandef, freq, cf) {
+	/* If any of channels unavailable for cf1 just return */
+	if (!r)
+		return r;
+
+	switch (chandef->width) {
+	case NL80211_CHAN_WIDTH_80P80:
+		WARN_ON(!chandef->center_freq2);
+		r = cfg80211_get_chans_dfs_available(wiphy,
+					MHZ_TO_KHZ(chandef->center_freq2),
+					width);
+		break;
+	default:
+		WARN_ON(chandef->center_freq2);
+		break;
+	}
+
+	return r;
+}
+
+static unsigned int cfg80211_get_chans_dfs_cac_time(struct wiphy *wiphy,
+						    u32 center_freq,
+						    u32 bandwidth)
+{
+	struct ieee80211_channel *c;
+	u32 start_freq, end_freq, freq;
+	unsigned int dfs_cac_ms = 0;
+
+	start_freq = cfg80211_get_start_freq(center_freq, bandwidth);
+	end_freq = cfg80211_get_end_freq(center_freq, bandwidth);
+
+	for (freq = start_freq; freq <= end_freq; freq += MHZ_TO_KHZ(20)) {
 		c = ieee80211_get_channel_khz(wiphy, freq);
 		if (!c)
-			return false;
+			return 0;
 
 		if (c->flags & IEEE80211_CHAN_DISABLED)
-			return false;
+			return 0;
 
-		if ((c->flags & IEEE80211_CHAN_RADAR) &&
-		    (c->dfs_state != NL80211_DFS_AVAILABLE) &&
-		    !(c->dfs_state == NL80211_DFS_USABLE && dfs_offload))
-			return false;
+		if (!(c->flags & IEEE80211_CHAN_RADAR))
+			continue;
+
+		if (c->dfs_cac_ms > dfs_cac_ms)
+			dfs_cac_ms = c->dfs_cac_ms;
 	}
 
-	return true;
+	return dfs_cac_ms;
 }
 
 unsigned int
 cfg80211_chandef_dfs_cac_time(struct wiphy *wiphy,
 			      const struct cfg80211_chan_def *chandef)
 {
-	struct ieee80211_channel *c;
 	int width;
 	unsigned int t1 = 0, t2 = 0;
 
@@ -1094,38 +1211,44 @@
 	if (width < 0)
 		return 0;
 
-	for_each_subchan(chandef, freq, cf) {
-		c = ieee80211_get_channel_khz(wiphy, freq);
-		if (!c || (c->flags & IEEE80211_CHAN_DISABLED)) {
-			if (cf == 1)
-				t1 = INT_MAX;
-			else
-				t2 = INT_MAX;
-			continue;
-		}
+	t1 = cfg80211_get_chans_dfs_cac_time(wiphy,
+					     MHZ_TO_KHZ(chandef->center_freq1),
+					     width);
 
-		if (!(c->flags & IEEE80211_CHAN_RADAR))
-			continue;
+	if (!chandef->center_freq2)
+		return t1;
 
-		if (cf == 1 && c->dfs_cac_ms > t1)
-			t1 = c->dfs_cac_ms;
+	t2 = cfg80211_get_chans_dfs_cac_time(wiphy,
+					     MHZ_TO_KHZ(chandef->center_freq2),
+					     width);
 
-		if (cf == 2 && c->dfs_cac_ms > t2)
-			t2 = c->dfs_cac_ms;
-	}
+	return max(t1, t2);
+}
+EXPORT_SYMBOL(cfg80211_chandef_dfs_cac_time);
 
-	if (t1 == INT_MAX && t2 == INT_MAX)
-		return 0;
+static bool cfg80211_secondary_chans_ok(struct wiphy *wiphy,
+					u32 center_freq, u32 bandwidth,
+					u32 prohibited_flags,
+					u32 permitting_flags)
+{
+	struct ieee80211_channel *c;
+	u32 freq, start_freq, end_freq;
 
-	if (t1 == INT_MAX)
-		return t2;
+	start_freq = cfg80211_get_start_freq(center_freq, bandwidth);
+	end_freq = cfg80211_get_end_freq(center_freq, bandwidth);
 
-	if (t2 == INT_MAX)
-		return t1;
+	for (freq = start_freq; freq <= end_freq; freq += MHZ_TO_KHZ(20)) {
+		c = ieee80211_get_channel_khz(wiphy, freq);
+		if (!c)
+			return false;
+		if (c->flags & permitting_flags)
+			continue;
+		if (c->flags & prohibited_flags)
+			return false;
+	}
 
-	return max(t1, t2);
+	return true;
 }
-EXPORT_SYMBOL(cfg80211_chandef_dfs_cac_time);
 
 /* check if the operating channels are valid and supported */
 static bool cfg80211_edmg_usable(struct wiphy *wiphy, u8 edmg_channels,
@@ -1192,7 +1315,6 @@
 	bool ext_nss_cap, support_80_80 = false, support_320 = false;
 	const struct ieee80211_sband_iftype_data *iftd;
 	struct ieee80211_supported_band *sband;
-	struct ieee80211_channel *c;
 	int i;
 
 	if (WARN_ON(!cfg80211_chandef_valid(chandef)))
@@ -1343,17 +1465,19 @@
 	if (width < 20)
 		prohibited_flags |= IEEE80211_CHAN_NO_OFDM;
 
-	for_each_subchan(chandef, freq, cf) {
-		c = ieee80211_get_channel_khz(wiphy, freq);
-		if (!c)
-			return false;
-		if (c->flags & permitting_flags)
-			continue;
-		if (c->flags & prohibited_flags)
+
+	if (!cfg80211_secondary_chans_ok(wiphy,
+					 ieee80211_chandef_to_khz(chandef),
+					 width, prohibited_flags,
+					 permitting_flags))
 			return false;
-	}
 
+	if (!chandef->center_freq2)
 	return true;
+	return cfg80211_secondary_chans_ok(wiphy,
+					   MHZ_TO_KHZ(chandef->center_freq2),
+					   width, prohibited_flags,
+					   permitting_flags);
 }
 
 bool cfg80211_chandef_usable(struct wiphy *wiphy,
